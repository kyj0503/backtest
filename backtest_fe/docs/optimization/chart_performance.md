# 차트 렌더링 성능 최적화

## 문제 상황

백테스트 기간이 길어질수록(예: 10년 이상) 차트에 표시해야 할 데이터 포인트가 수천 개에 달하면서 다음과 같은 성능 문제가 발생했습니다.

1.  **느린 초기 렌더링**: 차트 컴포넌트가 처음 마운트될 때 UI가 몇 초간 멈추는 현상.
2.  **상호작용 지연**: 차트 툴팁(Tooltip)에 마우스를 올리거나 슬라이더를 조작할 때 반응이 느리고 버벅거림.
3.  **불필요한 리렌더링**: 관련 없는 상태 변경에도 차트가 계속해서 다시 그려지는 문제.

## 원인 분석

### 1. Recharts 라이브러리의 특성

-   `Recharts`는 SVG 기반으로 차트를 렌더링합니다. 데이터 포인트가 많아질수록 DOM에 추가되는 SVG 요소의 수가 기하급수적으로 증가하여 브라우저에 큰 부담을 줍니다.
-   특히 `Tooltip`과 같은 상호작용 컴포넌트는 마우스 움직임에 따라 복잡한 계산을 수행하므로, 데이터 양이 많을 때 성능 저하의 주범이 됩니다.

### 2. 비효율적인 컴포넌트 구조 및 상태 관리

-   **무분별한 리렌더링**: `React.memo`, `useMemo`, `useCallback` 등의 메모이제이션 도구를 적절히 사용하지 않아, 상위 컴포넌트의 작은 상태 변화가 차트 전체의 리렌더링을 유발했습니다.
-   **거대한 `useChartData` 훅**: 차트 데이터 가공, 이벤트 핸들러, 상태 관리 등 너무 많은 책임이 하나의 훅에 집중되어 있었습니다. 이로 인해 작은 변경에도 전체 훅이 재실행되고, 불필요한 계산이 반복되었습니다.
-   **렌더링 중 계산**: 컴포넌트의 렌더링 함수 내에서 직접 데이터를 가공하거나 스타일을 계산하는 로직이 있어, 매 렌더링마다 비용이 큰 연산이 수행되었습니다.

## 해결 전략

성능 문제를 해결하기 위해 다음과 같은 다각적인 최적화 전략을 적용했습니다.

### 1. 컴포넌트 메모이제이션 (`React.memo`)

-   **목표**: 불필요한 리렌더링 방지.
-   **적용**: 차트와 관련된 모든 컴포넌트(`EquityChart`, `StatCards`, `TradeLogTable` 등)를 `React.memo`로 감쌌습니다.
-   **설명**: `React.memo`는 컴포넌트가 받는 `props`가 변경되지 않았을 경우, 마지막 렌더링 결과를 재사용하여 리렌더링을 건너뛰게 합니다. 이를 통해 상태 변경의 영향 범위를 최소화했습니다.

### 2. 데이터 및 함수 메모이제이션 (`useMemo`, `useCallback`)

-   **목표**: 비용이 큰 계산 결과와 함수 생성을 재사용.
-   **`useMemo`**:
    -   **적용**: 차트 데이터로 변환하는 로직, 통계 계산 로직 등 복잡한 연산 결과를 메모이제이션했습니다.
    -   **예시**: 백테스트 결과(`backtestResult`)가 변경될 때만 차트용 데이터(`chartData`)를 새로 계산하도록 `useMemo`를 사용했습니다.
        ```typescript
        const chartData = useMemo(() => {
          // backtestResult를 기반으로 차트 데이터를 가공하는 복잡한 로직
          return processedData;
        }, [backtestResult]);
        ```
-   **`useCallback`**:
    -   **적용**: 컴포넌트에 `prop`으로 전달되는 모든 이벤트 핸들러 함수를 `useCallback`으로 감쌌습니다.
    -   **설명**: `React.memo`를 효과적으로 사용하려면 `prop`으로 전달되는 함수가 매 렌더링마다 새로 생성되지 않아야 합니다. `useCallback`은 의존성이 변경되지 않는 한 함수를 재생성하지 않아, 자식 컴포넌트의 불필요한 리렌더링을 방지합니다.

### 3. 훅 분리 및 책임 최소화

-   **목표**: 거대했던 `useChartData` 훅의 책임을 분리하여 관심사를 분리하고 리렌더링 범위를 축소.
-   **리팩토링**:
    -   `useChartData` → `useBacktestResult`로 변경: 순수하게 백테스트 결과 데이터와 상태만 관리하도록 책임을 축소.
    -   `useChartInteractions`: 차트의 상호작용(줌, 패닝, 툴팁 등)과 관련된 상태 및 핸들러를 별도의 훅으로 분리.
    -   `usePerformanceStats`: 통계 계산 로직을 분리.
-   **효과**: 각 훅은 독립적인 상태와 로직을 가지므로, 하나의 상태 변경이 다른 부분에 영향을 주지 않게 되었습니다. 예를 들어, 차트 툴팁의 위치가 변경되어도 통계 계산 로직은 재실행되지 않습니다.

### 4. 데이터 다운샘플링

-   **목표**: 차트에 렌더링되는 데이터 포인트의 절대적인 수를 줄여 SVG 렌더링 부담을 완화.
-   **전략**: "스마트 샘플링" 기법을 도입했습니다. 이는 백테스트 기간에 따라 데이터의 집계 단위를 동적으로 변경하는 방식입니다. (상세 내용은 `data_sampling.md` 문서 참고)
-   **효과**: 10년치 일별 데이터(약 2500개)를 월별 데이터(120개)로 줄여 렌더링함으로써, 초기 로딩 속도와 상호작용 반응성을 극적으로 개선했습니다.

## 결론

차트 성능 문제는 단 한 가지 원인으로 발생한 것이 아니었습니다. `Recharts` 라이브러리의 근본적인 한계와 React 애플리케이션의 비효율적인 렌더링 관리가 복합적으로 작용한 결과입니다.

`React.memo`, `useMemo`, `useCallback`을 사용한 **철저한 메모이제이션**으로 불필요한 렌더링을 차단하고, **훅의 책임 분리**로 상태 변경의 영향 범위를 좁혔으며, **데이터 다운샘플링**으로 렌더링의 물리적인 부하를 줄이는 다각적인 접근을 통해 사용자가 체감할 수 있는 수준으로 성능을 개선할 수 있었습니다.

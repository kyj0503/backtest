# 성능 최적화 가이드

## 현재 성능 병목 지점

1.  **yfinance API (첫 데이터 로드)**: 전체 시간의 60-70% 차지
2.  **백테스트 실행**: 전체 시간의 20-30% 차지
3.  **MySQL 쿼리**: 전체 시간의 5-10% 차지
4.  **데이터 검증 및 변환**: 전체 시간의 5-10% 차지

## 적용된 최적화 전략

### 1. 다계층 캐싱 (DataRepository)

-   **인메모리 캐시**: 가장 빠른 캐시. 동일한 요청에 대해 즉시 응답합니다.
-   **DB 캐시 (MySQL)**: 인메모리 캐시가 없을 경우, DB에서 데이터를 조회합니다.
-   **동적 캐시 유효기간(TTL)**:
    -   **과거 데이터**: 변경될 일이 없으므로 24시간 동안 캐시합니다.
    -   **최신 데이터 (오늘 포함)**: 실시간 변동을 반영하기 위해 1시간 동안만 캐시합니다.
    -   이를 통해 불필요한 API 호출을 최소화하고, 과거 데이터에 대한 백테스트 속도를 크게 향상시켰습니다.

### 2. 데이터베이스 인덱싱

-   `daily_prices` 테이블에 `PRIMARY KEY (stock_id, date)` 복합 기본키를 설정하여, 특정 종목의 특정 기간 데이터를 조회하는 핵심 쿼리 성능을 최적화했습니다.
-   `database/check_and_create_indexes.sql` 스크립트를 통해 인덱스 상태를 검증할 수 있습니다.

### 3. 비동기 처리 최적화

-   `asyncio.to_thread()`를 사용하여 모든 동기 I/O(DB 조회, API 호출)를 별도 스레드에서 처리함으로써, 이벤트 루프 차단을 방지하고 경쟁 상태(Race Condition)를 해결했습니다.

### 4. 데이터 처리 최적화

-   Pandas 데이터프레임 처리 시, 여러 단계의 작업을 단일 체인으로 연결하여 불필요한 중간 과정과 메모리 할당을 줄였습니다.

    ```python
    # 최적화 전
    data = data.replace([np.inf, -np.inf], np.nan)
    data = data.dropna()

    # 최적화 후
    data = data.replace([np.inf, -np.inf], np.nan).dropna()
    ```

## 향후 최적화 계획

### 1. 병렬 데이터 로딩

-   포트폴리오 백테스트 시 여러 종목의 데이터를 `asyncio.gather`를 사용해 병렬로 로드하여, 데이터 준비 시간을 크게 단축할 수 있습니다.

### 2. 결과 캐싱

-   동일한 백테스트 요청(종목, 기간, 전략, 매개변수 등)에 대해서는 백테스트 결과 자체를 캐싱하여 즉시 반환하는 기능을 구현할 수 있습니다.

### 3. DB 커넥션 풀 튜닝

-   사용자 트래픽이 증가할 경우, `create_engine`의 `pool_size`와 `max_overflow` 옵션을 조정하여 DB 커넥션 병목 현상을 예방할 수 있습니다.

### 4. 비동기 DB 드라이버 도입

-   장기적으로 `aiomysql`과 같은 비동기 DB 드라이버와 SQLAlchemy 2.0의 비동기 지원을 도입하여, 데이터베이스 관련 작업을 완전히 비동기적으로 처리하는 것을 고려할 수 있습니다.

# DB 트랜잭션 격리로 인한 데이터 미조회 문제

## 요약

**심각도**: 높음
**영향 범위**: 포트폴리오 백테스트, 신규 종목 첫 실행

처음 사용하는 기간/종목에 대해 백테스트를 실행할 때, 첫 실행에서 잘못된 결과가 반환되고 동일한 조건으로 재실행하면 정상적인 결과가 나오는 문제가 발생했습니다.

## 증상

### 관찰된 현상

1.  **첫 실행 시 비정상 결과**: 비정상적인 수익률 및 차트 표시
2.  **두 번째 실행 시 정상 결과**: 동일한 매개변수로 재실행 시 정상 작동
3.  **새로운 종목/기간에서 반복**: DB 캐시가 없는 데이터에서만 발생

### 로그 분석

- yfinance에서 데이터를 가져와 DB에 저장 완료
- 직후 SELECT 쿼리 실행 시 "데이터가 없습니다" 오류 발생
- 잠시 후 재시도하면 성공

**핵심 문제점**: 데이터를 DB에 저장(INSERT)한 직후, 동일한 함수 내에서 해당 데이터를 조회(SELECT)하지 못합니다.

## 원인 분석

### 1. 코드 흐름

`app/services/yfinance_db.py`의 `_load_ticker_data_internal()` 함수에서, 데이터 조회를 위한 **커넥션 A**가 열린 상태에서, 누락된 데이터를 저장하기 위해 `save_ticker_data` 함수가 내부적으로 **커넥션 B**를 열어 데이터를 저장하고 닫습니다. 그 후 다시 **커넥션 A**를 사용해 데이터를 조회하려고 할 때 문제가 발생합니다.

### 2. 트랜잭션 격리 수준

**MySQL의 REPEATABLE READ 격리 수준 특성**:

-   트랜잭션이 시작된 시점의 데이터 스냅샷을 유지합니다.
-   다른 트랜잭션이 커밋한 데이터라도 현재 트랜잭션에서는 보이지 않습니다.

**문제 발생 시나리오**:

1.  **커넥션 A**가 트랜잭션을 시작합니다. 이 시점의 스냅샷에는 신규 데이터가 없습니다.
2.  **커넥션 B**가 새로운 트랜잭션을 열어 데이터를 저장하고 커밋합니다.
3.  다시 **커넥션 A**로 돌아와 데이터를 조회하면, 1번 시점의 스냅샷을 그대로 사용하므로 **커넥션 B**가 저장한 데이터가 보이지 않습니다.
4.  이로 인해 "데이터 없음" 오류가 발생합니다.
5.  잠시 후 재시도하면, 새로운 커넥션이 생성되어 최신 데이터가 반영된 스냅샷을 사용하므로 조회가 성공합니다.

## 해결 방법

`save_ticker_data()` 호출 후 커넥션을 명시적으로 재생성하여 새로운 트랜잭션 스냅샷을 얻도록 수정합니다.

#### 수정 전

```python
if df_new is not None and not df_new.empty:
    save_ticker_data(ticker, df_new)
# 커넥션 A가 계속 유지됨 - 문제 발생!

# 바로 SELECT 실행
res = conn.execute(text(q), params)
```

#### 수정 후

```python
if df_new is not None and not df_new.empty:
    save_ticker_data(ticker, df_new)
    
    # 데이터 저장 후 커넥션을 닫고 새로 연결
    conn.close()
    import time
    time.sleep(0.1)  # DB 커밋 완료 보장을 위한 짧은 대기
    conn = engine.connect()  # 새 트랜잭션 스냅샷

# 이제 최신 데이터가 보이는 새 커넥션으로 SELECT 실행
res = conn.execute(text(q), params)
```

`sleep(0.1)`은 DB 커밋이 물리적으로 완료될 시간을 보장하기 위한 안전장치입니다.

## 이전 비동기 문제와의 차이

-   **비동기 경쟁 상태 문제**: 비동기 컨텍스트에서 동기 I/O 함수를 직접 호출하여 발생. `asyncio.to_thread()`로 해결.
-   **트랜잭션 격리 문제 (현재)**: 동일 커넥션 내에서 다른 트랜잭션의 커밋 데이터가 보이지 않아 발생. 커넥션 재생성으로 해결.

두 문제는 독립적이지만, 모두 데이터 불일치를 유발할 수 있는 중요한 문제입니다.

## 교훈

-   **DB 트랜잭션 격리 수준 이해**: 특히 `REPEATABLE READ` 환경에서는 쓰기 후 읽기(Read-After-Write) 패턴에 주의해야 합니다.
-   **로깅의 중요성**: 상세한 로그(시도 횟수, 타이밍) 덕분에 문제의 원인을 파악할 수 있었습니다.
-   **재시도 메커니즘의 양면성**: 재시도는 일시적인 오류를 해결해주지만, 근본적인 원인을 가릴 수 있습니다. 재시도가 반복적으로 성공한다면 그 원인을 반드시 조사해야 합니다.

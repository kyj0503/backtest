# 날짜 계산 아키텍처 (N번째 특정 요일)

## 개요

본 시스템의 DCA(분할 매수) 및 리밸런싱 기능은 "매월 N번째 특정 요일"과 같은 복잡한 주기를 정확하게 처리해야 합니다. 예를 들어, "매월 3번째 금요일마다 투자"와 같은 사용자 요구사항을 일관성 있게 처리하기 위한 날짜 계산 로직이 `app/services/rebalance_helper.py`에 구현되어 있습니다.

## 핵심 문제와 해결 전략

주요 문제는 특정 월에는 "5번째 금요일"처럼 N번째 요일이 존재하지 않는 예외 상황입니다. 이러한 경우, 시스템은 다음과 같은 일관성 있는 규칙을 따릅니다.

- **원본 N값 유지**: 사용자가 처음에 "5번째" 주로 설정했다면, 시스템은 이 설정을 계속 기억합니다.
- **대체 실행 메커니즘**: 특정 월에 "5번째" 요일이 없다면, 해당 월에는 **마지막** 해당 요일에 투자를 실행합니다.
- **자동 복귀**: 다음 달에 "5번째" 요일이 다시 존재하면, 시스템은 원래 설정대로 5번째 요일에 투자를 재개합니다.

이 전략을 통해 사용자의 초기 설정을 최대한 존중하면서도 투자가 중단되지 않도록 보장합니다.

## 주요 함수 및 역할

### 1. `get_next_nth_weekday(current_date, period_type, interval, original_nth)`

- **역할**: 다음 DCA 또는 리밸런싱 실행 날짜를 계산하는 핵심 함수입니다.
- **동작**:
    1. `current_date`를 기준으로 `interval` 만큼의 주기(주/월) 후의 날짜를 계산합니다.
    2. `original_nth` 매개변수를 통해 사용자가 최초 설정한 "N번째" 값을 기억합니다.
    3. `get_nth_weekday_of_month` 함수를 호출하여 목표 날짜를 찾습니다.
    4. `original_nth` 값이 주어지지 않으면, `get_weekday_occurrence`를 통해 `current_date`로부터 N값을 추론합니다.

### 2. `get_nth_weekday_of_month(year, month, weekday, n)`

- **역할**: 특정 연도, 월의 "N번째 특정 요일"이 며칠인지 계산합니다.
- **동작**:
    1. 해당 월의 1일이 무슨 요일인지 파악합니다.
    2. 이를 기준으로 N번째 해당 요일의 날짜를 계산합니다.
    3. 만약 계산된 날짜가 해당 월의 마지막 날을 초과하면(예: 5번째 금요일이 없는 경우), 대신 **마지막 주**의 해당 요일 날짜를 반환합니다. 이것이 대체 실행 메커니즘의 핵심입니다.

### 3. `get_weekday_occurrence(date)`

- **역할**: 주어진 날짜가 그 달의 "몇 번째" 특정 요일인지 계산합니다.
- **동작**: 해당 월의 1일부터 주어진 날짜까지 순회하며 특정 요일이 몇 번 나타났는지 셉니다. `(date.day - 1) // 7 + 1`과 같은 단순 계산보다 정확합니다.

## 사용 흐름 (포트폴리오 서비스)

1.  **DCA/리밸런싱 첫 실행**: `portfolio_service`는 `get_weekday_occurrence`를 호출하여 시작 날짜의 "N번째" 값을 계산하고, 이를 `dca_info` 또는 `original_rebalance_nth` 변수에 저장합니다.
2.  **다음 실행일 계산**: 매일의 백테스트 루프에서 `RebalanceHelper.is_rebalance_date` 또는 `DCACalculator` 로직이 `get_next_nth_weekday`를 호출합니다. 이때 저장해둔 `original_nth` 값을 전달하여 일관성을 유지합니다.
3.  **실행**: 계산된 다음 실행일이 되면, DCA 또는 리밸런싱 로직이 실행됩니다.

이러한 구조를 통해, 월마다 주의 개수가 달라 발생하는 예외 상황을 안정적으로 처리하고 예측 가능한 투자 스케줄을 보장합니다.
